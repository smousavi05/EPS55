<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coulomb's Criterion: The Failure Rule</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #333; min-height: 100vh; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; background: rgba(255, 255, 255, 0.95); padding: 30px; border-radius: 20px; margin-bottom: 30px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2); }
        h1 { font-size: 3em; color: #2c3e50; }
        .main-content { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px; }
        .visualization-panel, .controls-panel { background: rgba(255, 255, 255, 0.95); padding: 30px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2); }
        #mohrCanvas { border: 2px solid #ddd; border-radius: 10px; background: white; margin-bottom: 20px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); }
        .control-group { margin-bottom: 25px; padding: 20px; background: #f8f9fa; border-radius: 12px; border-left: 4px solid #3498db; }
        .slider-container label { display: block; margin-bottom: 8px; font-weight: 600; color: #34495e; }
        .slider { width: 100%; }
        .value-display { display: inline-block; background: #3498db; color: white; padding: 4px 12px; border-radius: 15px; font-weight: bold; margin-left: 10px; }
        .status-indicator { padding: 15px; border-radius: 10px; text-align: center; font-weight: bold; font-size: 1.1em; margin-top: 20px; transition: all 0.3s ease; }
        .safe { background: linear-gradient(135deg, #2ecc71, #27ae60); color: white; }
        .failure { background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.02); } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header"><h1>⚡ Coulomb's Criterion</h1></div>
        <div class="main-content">
            <div class="visualization-panel">
                <canvas id="mohrCanvas" width="500" height="400"></canvas>
                <div id="statusIndicator" class="status-indicator safe">✅ MATERIAL IS SAFE</div>
            </div>
            <div class="controls-panel">
                 <div class="control-group">
                    <h3>Principal Stresses</h3>
                    <div class="slider-container">
                        <label for="sigma1">Maximum Principal Stress (σ₁) [MPa]</label>
                        <input type="range" id="sigma1" class="slider" min="0" max="100" value="60" step="1">
                        <span id="sigma1Value" class="value-display">60 MPa</span>
                    </div>
                    <div class="slider-container">
                        <label for="sigma3">Minimum Principal Stress (σ₃) [MPa]</label>
                        <input type="range" id="sigma3" class="slider" min="0" max="80" value="20" step="1">
                        <span id="sigma3Value" class="value-display">20 MPa</span>
                    </div>
                </div>
                <div class="control-group">
                    <h3>Material Properties</h3>
                    <div class="slider-container">
                        <label for="cohesion">Cohesion (c) [MPa]</label>
                        <input type="range" id="cohesion" class="slider" min="0" max="30" value="10" step="0.5">
                        <span id="cohesionValue" class="value-display">10.0 MPa</span>
                    </div>
                    <div class="slider-container">
                        <label for="friction">Friction Angle (φ) [degrees]</label>
                        <input type="range" id="friction" class="slider" min="10" max="60" value="30" step="1">
                        <span id="frictionValue" class="value-display">30°</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // *** DIAGNOSTIC TEST ***
        alert("Newest version of the code is running!");

        const canvas = document.getElementById('mohrCanvas');
        const ctx = canvas.getContext('2d');
        const sigma1Slider = document.getElementById('sigma1');
        const sigma3Slider = document.getElementById('sigma3');
        const cohesionSlider = document.getElementById('cohesion');
        const frictionSlider = document.getElementById('friction');
        const sigma1Value = document.getElementById('sigma1Value');
        const sigma3Value = document.getElementById('sigma3Value');
        const cohesionValue = document.getElementById('cohesionValue');
        const frictionValue = document.getElementById('frictionValue');
        const statusIndicator = document.getElementById('statusIndicator');

        function updateVisualization() {
            const sigma1 = parseFloat(sigma1Slider.value);
            const sigma3 = parseFloat(sigma3Slider.value);
            const c = parseFloat(cohesionSlider.value);
            const phi = parseFloat(frictionSlider.value);

            if (sigma1 < sigma3) { sigma1Slider.value = sigma3; return; }

            sigma1Value.textContent = `${sigma1} MPa`;
            sigma3Value.textContent = `${sigma3} MPa`;
            cohesionValue.textContent = `${c.toFixed(1)} MPa`;
            frictionValue.textContent = `${phi}°`;

            const center = (sigma1 + sigma3) / 2;
            const radius = (sigma1 - sigma3) / 2;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const margin = 40;
            const plotWidth = canvas.width - 2 * margin;
            const plotHeight = canvas.height - 2 * margin;
            
            const phiRad = phi * Math.PI / 180;
            const maxStress = Math.max(100, sigma1 * 1.2);
            const maxShearAxis = Math.max(50, radius * 1.5, c + maxStress * Math.tan(phiRad));
            const scaleX = plotWidth / maxStress;
            const scaleY = plotHeight / (2 * maxShearAxis);

            function toCanvasX(sigma) { return margin + sigma * scaleX; }
            function toCanvasY(tau) { return margin + plotHeight / 2 - tau * scaleY; }

            ctx.strokeStyle = '#eee'; ctx.lineWidth = 1;
            for (let i = 0; i <= maxStress; i += 20) { const x = toCanvasX(i); ctx.beginPath(); ctx.moveTo(x, margin); ctx.lineTo(x, margin + plotHeight); ctx.stroke(); }
            for (let i = -maxShearAxis; i <= maxShearAxis; i += 10) { if (i !== 0) { const y = toCanvasY(i); ctx.beginPath(); ctx.moveTo(margin, y); ctx.lineTo(margin + plotWidth, y); ctx.stroke(); } }

            ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(margin, toCanvasY(0)); ctx.lineTo(margin + plotWidth, toCanvasY(0)); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(toCanvasX(0), margin); ctx.lineTo(toCanvasX(0), margin + plotHeight); ctx.stroke();

            ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(toCanvasX(0), toCanvasY(c)); ctx.lineTo(toCanvasX(maxStress), toCanvasY(c + maxStress * Math.tan(phiRad))); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(toCanvasX(0), toCanvasY(-c)); ctx.lineTo(toCanvasX(maxStress), toCanvasY(-c - maxStress * Math.tan(phiRad))); ctx.stroke();

            const centerX = toCanvasX(center); const centerY = toCanvasY(0); const radiusPixels = radius * scaleX;
            ctx.strokeStyle = '#3498db'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(centerX, centerY, radiusPixels, 0, 2 * Math.PI); ctx.stroke();
            ctx.fillStyle = 'rgba(52, 152, 219, 0.1)'; ctx.fill();

            const requiredStrength = center * Math.sin(phiRad) + c * Math.cos(phiRad);
            const isFailing = radius + 1e-6 >= requiredStrength;

            if (isFailing) {
                statusIndicator.className = 'status-indicator failure'; statusIndicator.textContent = '❌ MATERIAL FAILURE PREDICTED';
                const failureSigma = center - radius * Math.sin(phiRad);
                const failureTau = radius * Math.cos(phiRad);
                const failureCanvasX = toCanvasX(failureSigma);
                const failureCanvasY = toCanvasY(failureTau);
                ctx.fillStyle = '#c0392b'; ctx.beginPath(); ctx.arc(failureCanvasX, failureCanvasY, 8, 0, 2 * Math.PI); ctx.fill();
                ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.stroke();
            } else {
                statusIndicator.className = 'status-indicator safe'; statusIndicator.textContent = '✅ MATERIAL IS SAFE';
            }
        }
        [sigma1Slider, sigma3Slider, cohesionSlider, frictionSlider].forEach(slider => slider.addEventListener('input', updateVisualization));
        updateVisualization();
    </script>
</body>
</html>
