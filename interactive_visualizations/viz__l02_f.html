<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Fault Visualization</title>
    <style>
        body { margin: 0; background-color: #f0f0f0; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
        }
        button {
            display: block;
            margin: 5px 0;
            padding: 8px 12px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="ui">
        <h3>Fault Types</h3>
        <button id="normalBtn">Normal Fault (Tension)</button>
        <button id="reverseBtn">Reverse Fault (Compression)</button>
        <button id="strikeSlipBtn">Strike-Slip Fault (Shear)</button>
        <button id="resetBtn">Reset</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/",
                "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@23.1.1/dist/tween.esm.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import TWEEN from '@tweenjs/tween.js';

        // === SCENE, CAMERA, RENDERER SETUP ===
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue background

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 25);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // === CONTROLS ===
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // === LIGHTING ===
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(20, 30, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // === GROUND PLANE ===
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // Forest green
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // === CREATE FAULT BLOCKS ===
        const faultAngle = 45 * Math.PI / 180; // 45-degree fault dip
        const blockWidth = 20;
        const blockDepth = 10;
        const layerHeight = 2;
        const numLayers = 5;

        const footwall = new THREE.Group();
        const hangingWall = new THREE.Group();
        scene.add(footwall, hangingWall);

        const layerColors = [0xd2b48c, 0x8b4513, 0x708090, 0x556b2f, 0xcd853f];

        // Create stratified layers for both blocks
        for (let i = 0; i < numLayers; i++) {
            const yPos = i * layerHeight - (numLayers * layerHeight) / 2 + layerHeight / 2;
            const material = new THREE.MeshStandardMaterial({ color: layerColors[i % layerColors.length] });

            // Footwall layer
            const fwGeom = new THREE.BoxGeometry(blockWidth, layerHeight, blockDepth);
            const fwLayer = new THREE.Mesh(fwGeom, material);
            fwLayer.castShadow = true;
            fwLayer.position.set(-blockWidth / 2, yPos, 0);
            footwall.add(fwLayer);
            
            // Hanging wall layer
            const hwGeom = new THREE.BoxGeometry(blockWidth, layerHeight, blockDepth);
            const hwLayer = new THREE.Mesh(hwGeom, material);
            hwLayer.castShadow = true;
            hwLayer.position.set(blockWidth / 2, yPos, 0);
            hangingWall.add(hwLayer);
        }

        // Position the blocks to create the fault plane
        footwall.position.x = -5;
        hangingWall.position.x = 5;
        hangingWall.rotation.z = -faultAngle;
        footwall.rotation.z = -faultAngle;
        
        const initialHangingWallPosition = new THREE.Vector3(5, 0, 0);
        
        // === ANIMATION LOGIC ===
        function animateFault(movement) {
            // Stop any existing tweens
            TWEEN.removeAll();
            
            new TWEEN.Tween(hangingWall.position)
                .to({
                    x: initialHangingWallPosition.x + movement.x,
                    y: initialHangingWallPosition.y + movement.y,
                    z: initialHangingWallPosition.z + movement.z
                }, 1500) // 1.5 seconds
                .easing(TWEEN.Easing.Quadratic.InOut)
                .start();
        }

        // === UI EVENT LISTENERS ===
        document.getElementById('normalBtn').addEventListener('click', () => {
            animateFault({ x: 3, y: -3, z: 0 }); // Down and away
        });

        document.getElementById('reverseBtn').addEventListener('click', () => {
            animateFault({ x: -3, y: 3, z: 0 }); // Up and in
        });

        document.getElementById('strikeSlipBtn').addEventListener('click', () => {
            animateFault({ x: 0, y: 0, z: 5 }); // Sideways
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            animateFault({ x: 0, y: 0, z: 0 }); // Back to original
        });

        // === RENDER LOOP ===
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            TWEEN.update();
            renderer.render(scene, camera);
        }

        // === RESIZE HANDLER ===
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
