<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Earthquake Cycle Visualization (Harvard EPS55)</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            margin: 0;
            font-size: 2rem;
            font-weight: 300;
        }

        .visualization-area {
            display: flex;
            height: 600px;
        }

        .main-viz {
            flex: 1;
            position: relative;
            background: #f8f9fa;
            border: 2px solid #ddd;
        }

        #faultCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: #e8f4f8;
        }

        .info-panel {
            width: 300px;
            background: #2c3e50;
            color: white;
            padding: 20px;
            overflow-y: auto;
        }

        .controls {
            background: #34495e;
            color: white;
            padding: 20px;
        }

        .timeline-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .time-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #bdc3c7;
            outline: none;
            -webkit-appearance: none;
        }

        .time-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #2980b9;
        }

        .btn.active {
            background: #e74c3c;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }

        .phase-indicator {
            background: #2c3e50;
            color: white;
            padding: 10px 20px;
            text-align: center;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .time-display {
            background: #34495e;
            color: white;
            padding: 10px;
            text-align: center;
            font-family: monospace;
            font-size: 1.1rem;
        }

        .legend {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            font-size: 12px;
            z-index: 10;
        }

        .legend h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 20px;
            height: 15px;
            margin-right: 8px;
            border: 1px solid #ccc;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }

        .speed-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #e74c3c;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Interactive Earthquake Cycle Visualization</h1>
            <p>Explore the complete earthquake cycle from stress accumulation to seismic release and recovery</p>
        </div>
        
        <div class="phase-indicator" id="phaseIndicator">
            Interseismic Phase - Stress Accumulation
        </div>
        
        <div class="time-display" id="timeDisplay">
            Year 0 | Elapsed: 0 years since last earthquake
        </div>
        
        <div class="visualization-area">
            <div class="main-viz">
                <canvas id="faultCanvas" width="800" height="600"></canvas>
                <div class="legend">
                    <h4>Stress Level</h4>
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(to right, #2ecc71, #f1c40f, #e74c3c);"></div>
                        <span>Low ‚Üí High</span>
                    </div>
                    <h4 style="margin-top: 15px;">Features</h4>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>GPS Stations</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>Aftershocks</span>
                    </div>
                </div>
            </div>
            
            <div class="info-panel">
                <div class="phase-info" id="phaseInfo">
                    <h3>Interseismic Phase</h3>
                    <p><strong>Duration:</strong> 50-300+ years</p>
                    <p><strong>Process:</strong> Tectonic plates move continuously, but the fault is locked due to friction. Elastic strain energy accumulates in the surrounding rocks.</p>
                    <p><strong>Observable Effects:</strong></p>
                    <ul>
                        <li>Gradual GPS displacement away from fault</li>
                        <li>Increasing stress concentration</li>
                        <li>Background seismicity</li>
                        <li>Slow deformation of surface features</li>
                    </ul>
                    <p><strong>Key Concepts:</strong> Elastic loading, stick-slip behavior, stress shadow effects</p>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="timeline-controls">
                <label for="timeSlider"><strong>Timeline Control</strong></label>
                <input type="range" id="timeSlider" class="time-slider" min="0" max="100" value="0">
                
                <div class="control-buttons">
                    <button class="btn" id="playBtn">‚ñ∂Ô∏è Play</button>
                    <button class="btn" id="pauseBtn">‚è∏Ô∏è Pause</button>
                    <button class="btn" id="resetBtn">üîÑ Reset</button>
                    <button class="btn" id="skipCoseismicBtn">‚ö° Trigger Earthquake</button>
                </div>
                
                <div class="speed-control">
                    <label>Speed:</label>
                    <input type="range" id="speedSlider" class="speed-slider" min="1" max="10" value="5">
                    <span id="speedDisplay">5x</span>
                </div>
                
                <div>
                    <h4>Display Options</h4>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showGPS" checked>
                        <label for="showGPS">GPS Vectors</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showStress" checked>
                        <label for="showStress">Stress Colors</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showForeslip">
                        <label for="showForeslip">Foreslip/Creep</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showAftershocks">
                        <label for="showAftershocks">Aftershocks</label>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize immediately when script loads
        console.log('Script starting...');

        let viz; // Global variable for the visualization

        class EarthquakeCycleViz {
            constructor() {
                console.log('Initializing visualization...');
                
                this.canvas = document.getElementById('faultCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Set explicit canvas size
                this.canvas.width = 800;
                this.canvas.height = 600;
                
                console.log('Canvas:', this.canvas, 'Context:', this.ctx);
                
                // Animation state
                this.currentTime = 0;
                this.isPlaying = false;
                this.animationSpeed = 5;
                this.lastTimestamp = 0;
                
                // Earthquake cycle phases
                this.phases = {
                    interseismic: { start: 0, end: 85 },
                    foreslip: { start: 85, end: 89 },
                    coseismic: { start: 89, end: 91 },
                    postseismic: { start: 91, end: 100 }
                };
                
                // Fault geometry
                this.faultLine = {
                    x1: 100, y1: 150,
                    x2: 700, y2: 450
                };
                
                // Generate GPS stations
                this.gpsStations = [];
                for (let i = 0; i < 15; i++) {
                    this.gpsStations.push({
                        x: 80 + Math.random() * 640,
                        y: 80 + Math.random() * 440,
                        displacement: { x: 0, y: 0 }
                    });
                }
                
                this.aftershocks = [];
                
                // Test canvas immediately
                this.testCanvas();
                
                // Setup controls
                this.setupControls();
                
                // Start animation loop
                this.animate();
                
                console.log('Visualization initialized');
            }
            
            testCanvas() {
                console.log('Testing canvas...');
                
                // Clear with blue background
                this.ctx.fillStyle = '#e8f4f8';
                this.ctx.fillRect(0, 0, 800, 600);
                
                // Draw test elements
                this.ctx.fillStyle = '#2c3e50';
                this.ctx.fillRect(50, 50, 100, 100);
                
                this.ctx.fillStyle = '#e74c3c';
                this.ctx.font = '20px Arial';
                this.ctx.fillText('EARTHQUAKE VISUALIZATION', 200, 100);
                
                // Draw fault line
                this.ctx.strokeStyle = '#34495e';
                this.ctx.lineWidth = 4;
                this.ctx.beginPath();
                this.ctx.moveTo(this.faultLine.x1, this.faultLine.y1);
                this.ctx.lineTo(this.faultLine.x2, this.faultLine.y2);
                this.ctx.stroke();
                
                console.log('Canvas test complete');
            }
            
            setupControls() {
                const playBtn = document.getElementById('playBtn');
                const pauseBtn = document.getElementById('pauseBtn');
                const resetBtn = document.getElementById('resetBtn');
                const skipBtn = document.getElementById('skipCoseismicBtn');
                const timeSlider = document.getElementById('timeSlider');
                const speedSlider = document.getElementById('speedSlider');
                
                if (playBtn) {
                    playBtn.addEventListener('click', () => {
                        console.log('Play clicked');
                        this.isPlaying = true;
                        playBtn.classList.add('active');
                        pauseBtn.classList.remove('active');
                    });
                }
                
                if (pauseBtn) {
                    pauseBtn.addEventListener('click', () => {
                        console.log('Pause clicked');
                        this.isPlaying = false;
                        pauseBtn.classList.add('active');
                        playBtn.classList.remove('active');
                    });
                }
                
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => {
                        console.log('Reset clicked');
                        this.currentTime = 0;
                        this.isPlaying = false;
                        this.aftershocks = [];
                        if (timeSlider) timeSlider.value = 0;
                        playBtn.classList.remove('active');
                        pauseBtn.classList.remove('active');
                    });
                }
                
                if (skipBtn) {
                    skipBtn.addEventListener('click', () => {
                        console.log('Skip to earthquake clicked');
                        this.currentTime = this.phases.coseismic.start;
                        if (timeSlider) timeSlider.value = this.currentTime;
                        this.triggerEarthquake();
                    });
                }
                
                if (timeSlider) {
                    timeSlider.addEventListener('input', (e) => {
                        this.currentTime = parseFloat(e.target.value);
                        console.log('Time slider changed to:', this.currentTime);
                    });
                }
                
                if (speedSlider) {
                    speedSlider.addEventListener('input', (e) => {
                        this.animationSpeed = parseInt(e.target.value);
                        const display = document.getElementById('speedDisplay');
                        if (display) display.textContent = `${this.animationSpeed}x`;
                    });
                }
            }
            
            getCurrentPhase() {
                if (this.currentTime <= this.phases.interseismic.end) return 'interseismic';
                if (this.currentTime <= this.phases.foreslip.end) return 'foreslip';
                if (this.currentTime <= this.phases.coseismic.end) return 'coseismic';
                return 'postseismic';
            }
            
            calculateStressLevel(x, y) {
                const phase = this.getCurrentPhase();
                const distanceToFault = this.distanceToFaultLine(x, y);
                const maxDistance = 200;
                const normalizedDistance = Math.min(distanceToFault / maxDistance, 1);
                
                let baseStress = 0;
                
                if (phase === 'interseismic') {
                    const progress = this.currentTime / this.phases.interseismic.end;
                    baseStress = progress * (1 - normalizedDistance * 0.7);
                } else if (phase === 'foreslip') {
                    baseStress = 0.9 * (1 - normalizedDistance * 0.7);
                } else if (phase === 'coseismic') {
                    baseStress = 0.1 * (1 - normalizedDistance * 0.5);
                } else {
                    const progress = (this.currentTime - this.phases.postseismic.start) / 
                                   (100 - this.phases.postseismic.start);
                    baseStress = (0.1 + progress * 0.4) * (1 - normalizedDistance * 0.7);
                }
                
                return Math.max(0, Math.min(1, baseStress));
            }
            
            distanceToFaultLine(x, y) {
                const { x1, y1, x2, y2 } = this.faultLine;
                const A = x - x1;
                const B = y - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                const param = lenSq ? dot / lenSq : 0;
                
                let xx, yy;
                if (param < 0) {
                    xx = x1; yy = y1;
                } else if (param > 1) {
                    xx = x2; yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                
                const dx = x - xx;
                const dy = y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            getStressColor(stressLevel) {
                if (stressLevel < 0.33) {
                    const t = stressLevel / 0.33;
                    const r = Math.floor(46 + t * (241 - 46));
                    const g = Math.floor(204 + t * (196 - 204));
                    const b = Math.floor(113 + t * (64 - 113));
                    return `rgb(${r}, ${g}, ${b})`;
                } else if (stressLevel < 0.66) {
                    const t = (stressLevel - 0.33) / 0.33;
                    const r = Math.floor(241 + t * (230 - 241));
                    const g = Math.floor(196 + t * (126 - 196));
                    const b = Math.floor(64 + t * (34 - 64));
                    return `rgb(${r}, ${g}, ${b})`;
                } else {
                    const t = (stressLevel - 0.66) / 0.34;
                    const r = Math.floor(230 + t * (231 - 230));
                    const g = Math.floor(126 + t * (76 - 126));
                    const b = Math.floor(34 + t * (60 - 34));
                    return `rgb(${r}, ${g}, ${b})`;
                }
            }
            
            calculateGPSDisplacement(station) {
                const phase = this.getCurrentPhase();
                const distanceToFault = this.distanceToFaultLine(station.x, station.y);
                const faultNormal = this.getFaultNormal(station.x, station.y);
                
                let displacement = { x: 0, y: 0 };
                
                if (phase === 'interseismic') {
                    const progress = this.currentTime / this.phases.interseismic.end;
                    const magnitude = progress * 12 * Math.exp(-distanceToFault / 150);
                    displacement.x = faultNormal.x * magnitude;
                    displacement.y = faultNormal.y * magnitude;
                } else if (phase === 'coseismic') {
                    const magnitude = 20 * Math.exp(-distanceToFault / 200);
                    displacement.x = faultNormal.x * magnitude;
                    displacement.y = faultNormal.y * magnitude * 0.5;
                } else if (phase === 'postseismic') {
                    const magnitude = 15 * Math.exp(-distanceToFault / 180);
                    displacement.x = faultNormal.x * magnitude;
                    displacement.y = faultNormal.y * magnitude * 0.5;
                }
                
                return displacement;
            }
            
            getFaultNormal(x, y) {
                const { x1, y1, x2, y2 } = this.faultLine;
                const faultVector = { x: x2 - x1, y: y2 - y1 };
                const length = Math.sqrt(faultVector.x * faultVector.x + faultVector.y * faultVector.y);
                
                const normal = { x: -faultVector.y / length, y: faultVector.x / length };
                
                const side = (x - x1) * faultVector.y - (y - y1) * faultVector.x;
                return side > 0 ? normal : { x: -normal.x, y: -normal.y };
            }
            
            triggerEarthquake() {
                console.log('Triggering earthquake!');
                this.generateAftershocks();
            }
            
            generateAftershocks() {
                this.aftershocks = [];
                for (let i = 0; i < 20; i++) {
                    const t = Math.random();
                    const x = this.faultLine.x1 + t * (this.faultLine.x2 - this.faultLine.x1);
                    const y = this.faultLine.y1 + t * (this.faultLine.y2 - this.faultLine.y1);
                    
                    const scatter = 40;
                    this.aftershocks.push({
                        x: x + (Math.random() - 0.5) * scatter,
                        y: y + (Math.random() - 0.5) * scatter,
                        magnitude: 1 + Math.random() * 3,
                        time: this.phases.postseismic.start + Math.random() * 
                              (100 - this.phases.postseismic.start),
                        decayRate: 0.1 + Math.random() * 0.15
                    });
                }
            }
            
            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#e8f4f8';
                this.ctx.fillRect(0, 0, 800, 600);
                
                // Draw stress field if enabled
                const showStress = document.getElementById('showStress');
                if (showStress && showStress.checked) {
                    const gridSize = 12;
                    for (let x = 0; x < 800; x += gridSize) {
                        for (let y = 0; y < 600; y += gridSize) {
                            const stressLevel = this.calculateStressLevel(x, y);
                            this.ctx.fillStyle = this.getStressColor(stressLevel);
                            this.ctx.fillRect(x, y, gridSize, gridSize);
                        }
                    }
                }
                
                // Draw fault line
                this.ctx.strokeStyle = '#2c3e50';
                this.ctx.lineWidth = 5;
                this.ctx.beginPath();
                this.ctx.moveTo(this.faultLine.x1, this.faultLine.y1);
                this.ctx.lineTo(this.faultLine.x2, this.faultLine.y2);
                this.ctx.stroke();
                
                // Draw fault label
                this.ctx.fillStyle = '#2c3e50';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.fillText('FAULT LINE', this.faultLine.x1 - 30, this.faultLine.y1 - 15);
                
                // Draw GPS stations
                const showGPS = document.getElementById('showGPS');
                if (showGPS && showGPS.checked) {
                    this.gpsStations.forEach(station => {
                        const displacement = this.calculateGPSDisplacement(station);
                        
                        // Draw station
                        this.ctx.fillStyle = '#3498db';
                        this.ctx.beginPath();
                        this.ctx.arc(station.x, station.y, 5, 0, 2 * Math.PI);
                        this.ctx.fill();
                        
                        // Draw displacement vector
                        const magnitude = Math.sqrt(displacement.x * displacement.x + displacement.y * displacement.y);
                        if (magnitude > 0.5) {
                            const scale = 3;
                            this.ctx.strokeStyle = '#3498db';
                            this.ctx.lineWidth = 3;
                            this.ctx.beginPath();
                            this.ctx.moveTo(station.x, station.y);
                            this.ctx.lineTo(station.x + displacement.x * scale, 
                                          station.y + displacement.y * scale);
                            this.ctx.stroke();
                            
                            // Arrow head
                            const angle = Math.atan2(displacement.y, displacement.x);
                            const headLength = 8;
                            this.ctx.beginPath();
                            this.ctx.moveTo(station.x + displacement.x * scale, 
                                          station.y + displacement.y * scale);
                            this.ctx.lineTo(
                                station.x + displacement.x * scale - headLength * Math.cos(angle - Math.PI / 6),
                                station.y + displacement.y * scale - headLength * Math.sin(angle - Math.PI / 6)
                            );
                            this.ctx.moveTo(station.x + displacement.x * scale, 
                                          station.y + displacement.y * scale);
                            this.ctx.lineTo(
                                station.x + displacement.x * scale - headLength * Math.cos(angle + Math.PI / 6),
                                station.y + displacement.y * scale - headLength * Math.sin(angle + Math.PI / 6)
                            );
                            this.ctx.stroke();
                        }
                    });
                }
                
                // Draw aftershocks
                const showAftershocks = document.getElementById('showAftershocks');
                if (showAftershocks && showAftershocks.checked && this.getCurrentPhase() === 'postseismic') {
                    this.aftershocks.forEach(aftershock => {
                        if (this.currentTime >= aftershock.time) {
                            const timeSinceShock = this.currentTime - aftershock.time;
                            const opacity = Math.exp(-timeSinceShock * aftershock.decayRate);
                            
                            if (opacity > 0.1) {
                                this.ctx.fillStyle = `rgba(231, 76, 60, ${opacity})`;
                                this.ctx.beginPath();
                                this.ctx.arc(aftershock.x, aftershock.y, 
                                           aftershock.magnitude * 2, 0, 2 * Math.PI);
                                this.ctx.fill();
                            }
                        }
                    });
                }
            }
            
            updatePhaseInfo() {
                const phase = this.getCurrentPhase();
                const phaseIndicator = document.getElementById('phaseIndicator');
                const timeDisplay = document.getElementById('timeDisplay');
                
                const phaseData = {
                    interseismic: {
                        title: 'Interseismic Phase - Stress Accumulation',
                        time: () => {
                            const years = Math.floor(this.currentTime * 3);
                            return `Year ${years} | Elapsed: ${years} years since last earthquake`;
                        }
                    },
                    foreslip: {
                        title: 'Foreslip Phase - Pre-earthquake Creep',
                        time: () => 'Days before earthquake | Foreslip detected'
                    },
                    coseismic: {
                        title: 'Coseismic Phase - Main Rupture',
                        time: () => 'EARTHQUAKE IN PROGRESS'
                    },
                    postseismic: {
                        title: 'Postseismic Phase - Recovery and Adjustment',
                        time: () => {
                            const years = Math.floor((this.currentTime - this.phases.postseismic.start) * 20);
                            return `Year ${years} after earthquake | Recovery phase`;
                        }
                    }
                };
                
                const data = phaseData[phase];
                if (phaseIndicator) phaseIndicator.textContent = data.title;
                if (timeDisplay) timeDisplay.textContent = data.time();
            }
            
            animate(timestamp = 0) {
                if (this.isPlaying) {
                    const deltaTime = timestamp - this.lastTimestamp;
                    this.currentTime += (deltaTime / 1000) * this.animationSpeed * 0.3;
                    
                    if (this.currentTime > 100) {
                        this.currentTime = 0;
                        this.aftershocks = [];
                    }
                    
                    // Auto-trigger earthquake
                    if (this.getCurrentPhase() === 'coseismic' && 
                        Math.floor(this.currentTime) === this.phases.coseismic.start) {
                        this.triggerEarthquake();
                    }
                    
                    const timeSlider = document.getElementById('timeSlider');
                    if (timeSlider) timeSlider.value = this.currentTime;
                }
                
                this.lastTimestamp = timestamp;
                
                // Draw everything
                this.draw();
                this.updatePhaseInfo();
                
                requestAnimationFrame((ts) => this.animate(ts));
            }
        }
        
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                console.log('DOM loaded, creating visualization...');
                viz = new EarthquakeCycleViz();
            });
        } else {
            console.log('DOM already loaded, creating visualization...');
            viz = new EarthquakeCycleViz();
        }
    </script>
</body>
</html>
